openzeppelin:
{"time":95,"results":[{"type":"external-function ","before":"function onERC721Received(\n address,\n address,\n uint256,\n bytes memory\n ) public virtual override returns (bytes4) {\n return this.onERC721Received.selector;\n }","after":"function onERC721Received(\n address,\n address,\n uint256,\n bytes calldata\n ) public virtual override returns (bytes4) {\n return this.onERC721Received.selector;\n }","contract":"ERC721Holder","time":0}]}

{"time":283,"results":[{"type":"external-function ","before":"function send(\n address recipient,\n uint256 amount,\n bytes memory data\n ) public virtual override {\n _send(_msgSender(), recipient, amount, data, \"\", true);\n }","after":"function send(\n address recipient,\n uint256 amount,\n bytes calldata data\n ) public virtual override {\n _send(_msgSender(), recipient, amount, data, \"\", true);\n }","contract":"ERC777","time":0},
{"type":"external-function ","before":"function burn(uint256 amount, bytes memory data) public virtual override {\n _burn(_msgSender(), amount, data, \"\");\n }","after":"function burn(uint256 amount, bytes calldata data) public virtual override {\n _burn(_msgSender(), amount, data, \"\");\n }","contract":"ERC777","time":0},
{"type":"external-function ","before":"function operatorSend(\n address sender,\n address recipient,\n uint256 amount,\n bytes memory data,\n bytes memory operatorData\n ) public virtual override {\n require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n _send(sender, recipient, amount, data, operatorData, true);\n }","after":"function operatorSend(\n address sender,\n address recipient,\n uint256 amount,\n bytes calldata data,\n bytes calldata operatorData\n ) public virtual override {\n require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n _send(sender, recipient, amount, data, operatorData, true);\n }","contract":"ERC777","time":0},
{"type":"external-function ","before":"function operatorBurn(\n address account,\n uint256 amount,\n bytes memory data,\n bytes memory operatorData\n ) public virtual override {\n require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n _burn(account, amount, data, operatorData);\n }","after":"function operatorBurn(\n address account,\n uint256 amount,\n bytes calldata data,\n bytes calldata operatorData\n ) public virtual override {\n require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n _burn(account, amount, data, operatorData);\n }","contract":"ERC777","time":0}]}

{"time":310,"results":[{"type":"external-function ","before":"function safeTransferFrom(\n address from,\n address to,\n uint256 id,\n uint256 amount,\n bytes memory data\n ) public virtual override {\n require(\n from == _msgSender() || isApprovedForAll(from, _msgSender()),\n \"ERC1155: caller is not token owner or approved\"\n );\n _safeTransferFrom(from, to, id, amount, data);\n }","after":"function safeTransferFrom(\n address from,\n address to,\n uint256 id,\n uint256 amount,\n bytes calldata data\n ) public virtual override {\n require(\n from == _msgSender() || isApprovedForAll(from, _msgSender()),\n \"ERC1155: caller is not token owner or approved\"\n );\n _safeTransferFrom(from, to, id, amount, data);\n }","contract":"ERC1155","time":0},
{"type":"external-function ","before":"function safeBatchTransferFrom(\n address from,\n address to,\n uint256[] memory ids,\n uint256[] memory amounts,\n bytes memory data\n ) public virtual override {\n require(\n from == _msgSender() || isApprovedForAll(from, _msgSender()),\n \"ERC1155: caller is not token owner or approved\"\n );\n _safeBatchTransferFrom(from, to, ids, amounts, data);\n }","after":"function safeBatchTransferFrom(\n address from,\n address to,\n uint256[] calldata ids,\n uint256[] calldata amounts,\n bytes calldata data\n ) public virtual override {\n require(\n from == _msgSender() || isApprovedForAll(from, _msgSender()),\n \"ERC1155: caller is not token owner or approved\"\n );\n _safeBatchTransferFrom(from, to, ids, amounts, data);\n }","contract":"ERC1155","time":0}]}

{"time":125,"results":[{"type":"external-function ","before":"function burnBatch(\n address account,\n uint256[] memory ids,\n uint256[] memory values\n ) public virtual {\n require(\n account == _msgSender() || isApprovedForAll(account, _msgSender()),\n \"ERC1155: caller is not token owner or approved\"\n );\n\n _burnBatch(account, ids, values);\n }","after":"function burnBatch(\n address account,\n uint256[] calldata ids,\n uint256[] calldata values\n ) public virtual {\n require(\n account == _msgSender() || isApprovedForAll(account, _msgSender()),\n \"ERC1155: caller is not token owner or approved\"\n );\n\n _burnBatch(account, ids, values);\n }","contract":"ERC1155Burnable","time":0}]}

{"time":100,"results":[{"type":"external-function ","before":"function onERC1155Received(\n address,\n address,\n uint256,\n uint256,\n bytes memory\n ) public virtual override returns (bytes4) {\n return this.onERC1155Received.selector;\n }","after":"function onERC1155Received(\n address,\n address,\n uint256,\n uint256,\n bytes calldata\n ) public virtual override returns (bytes4) {\n return this.onERC1155Received.selector;\n }","contract":"ERC1155Holder","time":0},
{"type":"external-function ","before":"function onERC1155BatchReceived(\n address,\n address,\n uint256[] memory,\n uint256[] memory,\n bytes memory\n ) public virtual override returns (bytes4) {\n return this.onERC1155BatchReceived.selector;\n }","after":"function onERC1155BatchReceived(\n address,\n address,\n uint256[] calldata,\n uint256[] calldata,\n bytes calldata\n ) public virtual override returns (bytes4) {\n return this.onERC1155BatchReceived.selector;\n }","contract":"ERC1155Holder","time":0}]}

{"time":183,"results":[{"type":"external-function ","before":"function mint(\n address to,\n uint256 id,\n uint256 amount,\n bytes memory data\n ) public virtual {\n require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n _mint(to, id, amount, data);\n }","after":"function mint(\n address to,\n uint256 id,\n uint256 amount,\n bytes calldata data\n ) public virtual {\n require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n _mint(to, id, amount, data);\n }","contract":"ERC1155PresetMinterPauser","time":0},
{"type":"external-function ","before":"function mintBatch(\n address to,\n uint256[] memory ids,\n uint256[] memory amounts,\n bytes memory data\n ) public virtual {\n require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n _mintBatch(to, ids, amounts, data);\n }","after":"function mintBatch(\n address to,\n uint256[] calldata ids,\n uint256[] calldata amounts,\n bytes calldata data\n ) public virtual {\n require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n _mintBatch(to, ids, amounts, data);\n }","contract":"ERC1155PresetMinterPauser","time":0}]}
{"time":407,"results":[{"type":"external-function ","before":"function propose(\n address[] memory targets,\n uint256[] memory values,\n bytes[] memory calldatas,\n string memory description\n ) public virtual override returns (uint256) {\n require(\n getVotes(_msgSender(), block.number - 1) >= proposalThreshold(),\n \"Governor: proposer votes below proposal threshold\"\n );\n\n uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n require(targets.length == values.length, \"Governor: invalid proposal length\");\n require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n require(targets.length > 0, \"Governor: empty proposal\");\n\n ProposalCore storage proposal = _proposals[proposalId];\n require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\n uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\n uint64 deadline = snapshot + votingPeriod().toUint64();\n\n proposal.voteStart.setDeadline(snapshot);\n proposal.voteEnd.setDeadline(deadline);\n\n emit ProposalCreated(\n proposalId,\n _msgSender(),\n targets,\n values,\n new string[](targets.length),\n calldatas,\n snapshot,\n deadline,\n description\n );\n\n return proposalId;\n }","after":"function propose(\n address[] calldata targets,\n uint256[] calldata values,\n bytes[] calldata calldatas,\n string calldata description\n ) public virtual override returns (uint256) {\n require(\n getVotes(_msgSender(), block.number - 1) >= proposalThreshold(),\n \"Governor: proposer votes below proposal threshold\"\n );\n\n uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n require(targets.length == values.length, \"Governor: invalid proposal length\");\n require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n require(targets.length > 0, \"Governor: empty proposal\");\n\n ProposalCore storage proposal = _proposals[proposalId];\n require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\n uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\n uint64 deadline = snapshot + votingPeriod().toUint64();\n\n proposal.voteStart.setDeadline(snapshot);\n proposal.voteEnd.setDeadline(deadline);\n\n emit ProposalCreated(\n proposalId,\n _msgSender(),\n targets,\n values,\n new string[](targets.length),\n calldatas,\n snapshot,\n deadline,\n description\n );\n\n return proposalId;\n }","contract":"Governor","time":0},
{"type":"external-function ","before":"function execute(\n address[] memory targets,\n uint256[] memory values,\n bytes[] memory calldatas,\n bytes32 descriptionHash\n ) public payable virtual override returns (uint256) {\n uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n ProposalState status = state(proposalId);\n require(\n status == ProposalState.Succeeded || status == ProposalState.Queued,\n \"Governor: proposal not successful\"\n );\n _proposals[proposalId].executed = true;\n\n emit ProposalExecuted(proposalId);\n\n _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n _execute(proposalId, targets, values, calldatas, descriptionHash);\n _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n return proposalId;\n }","after":"function execute(\n address[] calldata targets,\n uint256[] calldata values,\n bytes[] calldata calldatas,\n bytes32 descriptionHash\n ) public payable virtual override returns (uint256) {\n uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n ProposalState status = state(proposalId);\n require(\n status == ProposalState.Succeeded || status == ProposalState.Queued,\n \"Governor: proposal not successful\"\n );\n _proposals[proposalId].executed = true;\n\n emit ProposalExecuted(proposalId);\n\n _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n _execute(proposalId, targets, values, calldatas, descriptionHash);\n _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n return proposalId;\n }","contract":"Governor","time":0},
{"type":"external-function ","before":"function castVoteWithReasonAndParams(\n uint256 proposalId,\n uint8 support,\n string calldata reason,\n bytes memory params\n ) public virtual override returns (uint256) {\n address voter = _msgSender();\n return _castVote(proposalId, voter, support, reason, params);\n }","after":"function castVoteWithReasonAndParams(\n uint256 proposalId,\n uint8 support,\n string calldata reason,\n bytes calldata params\n ) public virtual override returns (uint256) {\n address voter = _msgSender();\n return _castVote(proposalId, voter, support, reason, params);\n }","contract":"Governor","time":0},
{"type":"external-function ","before":"function castVoteWithReasonAndParamsBySig(\n uint256 proposalId,\n uint8 support,\n string calldata reason,\n bytes memory params,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public virtual override returns (uint256) {\n address voter = ECDSA.recover(\n _hashTypedDataV4(\n keccak256(\n abi.encode(\n EXTENDED_BALLOT_TYPEHASH,\n proposalId,\n support,\n keccak256(bytes(reason)),\n keccak256(params)\n )\n )\n ),\n v,\n r,\n s\n );\n\n return _castVote(proposalId, voter, support, reason, params);\n }","after":"function castVoteWithReasonAndParamsBySig(\n uint256 proposalId,\n uint8 support,\n string calldata reason,\n bytes calldata params,\n uint8 v,\n bytes32 r,\n bytes32 s\n ) public virtual override returns (uint256) {\n address voter = ECDSA.recover(\n _hashTypedDataV4(\n keccak256(\n abi.encode(\n EXTENDED_BALLOT_TYPEHASH,\n proposalId,\n support,\n keccak256(bytes(reason)),\n keccak256(params)\n )\n )\n ),\n v,\n r,\n s\n );\n\n return _castVote(proposalId, voter, support, reason, params);\n }","contract":"Governor","time":0},
{"type":"external-function ","before":"function onERC721Received(\n address,\n address,\n uint256,\n bytes memory\n ) public virtual override returns (bytes4) {\n return this.onERC721Received.selector;\n }","after":"function onERC721Received(\n address,\n address,\n uint256,\n bytes calldata\n ) public virtual override returns (bytes4) {\n return this.onERC721Received.selector;\n }","contract":"Governor","time":0},
{"type":"external-function ","before":"function onERC1155Received(\n address,\n address,\n uint256,\n uint256,\n bytes memory\n ) public virtual override returns (bytes4) {\n return this.onERC1155Received.selector;\n }","after":"function onERC1155Received(\n address,\n address,\n uint256,\n uint256,\n bytes calldata\n ) public virtual override returns (bytes4) {\n return this.onERC1155Received.selector;\n }","contract":"Governor","time":0},
{"type":"external-function ","before":"function onERC1155BatchReceived(\n address,\n address,\n uint256[] memory,\n uint256[] memory,\n bytes memory\n ) public virtual override returns (bytes4) {\n return this.onERC1155BatchReceived.selector;\n }","after":"function onERC1155BatchReceived(\n address,\n address,\n uint256[] calldata,\n uint256[] calldata,\n bytes calldata\n ) public virtual override returns (bytes4) {\n return this.onERC1155BatchReceived.selector;\n }","contract":"Governor","time":0}]}

{"time":6,"results":[{"type":"external-function ","before":"function propose(\n address[] memory targets,\n uint256[] memory values,\n bytes[] memory calldatas,\n string memory description\n ) public virtual override returns (uint256) {\n return super.propose(targets, values, calldatas, description);\n }","after":"function propose(\n address[] calldata targets,\n uint256[] calldata values,\n bytes[] calldata calldatas,\n string calldata description\n ) public virtual override returns (uint256) {\n return super.propose(targets, values, calldatas, description);\n }","contract":"GovernorProposalThreshold","time":0}]}
{"time":110,"results":[{"type":"external-function ","before":"function queue(\n address[] memory targets,\n uint256[] memory values,\n bytes[] memory calldatas,\n bytes32 descriptionHash\n ) public virtual override returns (uint256) {\n uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n uint256 eta = block.timestamp + _timelock.delay();\n _proposalTimelocks[proposalId].timer.setDeadline(eta.toUint64());\n for (uint256 i = 0; i < targets.length; ++i) {\n require(\n !_timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], eta))),\n \"GovernorTimelockCompound: identical proposal action already queued\"\n );\n _timelock.queueTransaction(targets[i], values[i], \"\", calldatas[i], eta);\n }\n\n emit ProposalQueued(proposalId, eta);\n\n return proposalId;\n }","after":"function queue(\n address[] calldata targets,\n uint256[] calldata values,\n bytes[] calldata calldatas,\n bytes32 descriptionHash\n ) public virtual override returns (uint256) {\n uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n uint256 eta = block.timestamp + _timelock.delay();\n _proposalTimelocks[proposalId].timer.setDeadline(eta.toUint64());\n for (uint256 i = 0; i < targets.length; ++i) {\n require(\n !_timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], eta))),\n \"GovernorTimelockCompound: identical proposal action already queued\"\n );\n _timelock.queueTransaction(targets[i], values[i], \"\", calldatas[i], eta);\n }\n\n emit ProposalQueued(proposalId, eta);\n\n return proposalId;\n }","contract":"GovernorTimelockCompound","time":0}]}

{"time":49,"results":[{"type":"external-function ","before":"function queue(\n address[] memory targets,\n uint256[] memory values,\n bytes[] memory calldatas,\n bytes32 descriptionHash\n ) public virtual override returns (uint256) {\n uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n uint256 delay = _timelock.getMinDelay();\n _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);\n _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);\n\n emit ProposalQueued(proposalId, block.timestamp + delay);\n\n return proposalId;\n }","after":"function queue(\n address[] calldata targets,\n uint256[] calldata values,\n bytes[] calldata calldatas,\n bytes32 descriptionHash\n ) public virtual override returns (uint256) {\n uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n uint256 delay = _timelock.getMinDelay();\n _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);\n _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);\n\n emit ProposalQueued(proposalId, block.timestamp + delay);\n\n return proposalId;\n }","contract":"GovernorTimelockControl","time":0}]}

{"time":10,"results":[{"type":"struct-data-arrangement ","before":"\nuint256 id\naddress proposer\nuint256 eta\naddress[] targets\nuint256[] values\nstring[] signatures\nbytes[] calldatas\nuint256 startBlock\nuint256 endBlock\nuint256 forVotes\nuint256 againstVotes\nuint256 abstainVotes\nbool canceled\nbool executed\nmapping(address => Receipt) receipts","after":"uint256 id\nuint256 eta\naddress[] targets\nuint256[] values\nstring[] signatures\nbytes[] calldatas\nuint256 startBlock\nuint256 endBlock\nuint256 forVotes\nuint256 againstVotes\nuint256 abstainVotes\nmapping(address => Receipt) receipts\naddress proposer\nbool canceled\nbool executed\n","contract":"IGovernorCompatibilityBravo","time":1}]}

{"time":136,"results":[{"type":"external-function ","before":"function upgradeAndCall(\n TransparentUpgradeableProxy proxy,\n address implementation,\n bytes memory data\n ) public payable virtual onlyOwner {\n proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n }","after":"function upgradeAndCall(\n TransparentUpgradeableProxy proxy,\n address implementation,\n bytes calldata data\n ) public payable virtual onlyOwner {\n proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n }","contract":"ProxyAdmin","time":0}]}

{"time":130,"results":[{"type":"external-function ","before":"function onERC721Received(\n address,\n address,\n uint256,\n bytes memory\n ) public virtual override returns (bytes4) {\n return this.onERC721Received.selector;\n }","after":"function onERC721Received(\n address,\n address,\n uint256,\n bytes calldata\n ) public virtual override returns (bytes4) {\n return this.onERC721Received.selector;\n }","contract":"TimelockController","time":0},
{"type":"external-function ","before":"function onERC1155Received(\n address,\n address,\n uint256,\n uint256,\n bytes memory\n ) public virtual override returns (bytes4) {\n return this.onERC1155Received.selector;\n }","after":"function onERC1155Received(\n address,\n address,\n uint256,\n uint256,\n bytes calldata\n ) public virtual override returns (bytes4) {\n return this.onERC1155Received.selector;\n }","contract":"TimelockController","time":0},
{"type":"external-function ","before":"function onERC1155BatchReceived(\n address,\n address,\n uint256[] memory,\n uint256[] memory,\n bytes memory\n ) public virtual override returns (bytes4) {\n return this.onERC1155BatchReceived.selector;\n }","after":"function onERC1155BatchReceived(\n address,\n address,\n uint256[] calldata,\n uint256[] calldata,\n bytes calldata\n ) public virtual override returns (bytes4) {\n return this.onERC1155BatchReceived.selector;\n }","contract":"TimelockController","time":0}]}

{"time":36,"results":[{"type":"external-function ","before":"function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n _authorizeUpgrade(newImplementation);\n _upgradeToAndCallUUPS(newImplementation, data, true);\n }","after":"function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual onlyProxy {\n _authorizeUpgrade(newImplementation);\n _upgradeToAndCallUUPS(newImplementation, data, true);\n }","contract":"UUPSUpgradeable","time":0},
{"type":"constant-restrict-modification ","before":"address private immutable __self = address(this);","after":"address private immutable constant __self = address(this);","contract":"UUPSUpgradeable","time":0}]} (FP)

seadrop:
{"time":100,"results":[{"type":"external-function ","before":"function updateSignedMintValidationParams(\n address seaDropImpl,\n address signer,\n SignedMintValidationParams memory signedMintValidationParams\n )\n external\n virtual\n override\n onlyOwnerOrAdministrator\n onlyAllowedSeaDrop(seaDropImpl)\n {\n // Track the previous signed mint validation params.\n SignedMintValidationParams memory retrieved = ISeaDrop(seaDropImpl)\n .getSignedMintValidationParams(address(this), signer);\n\n // Track the newly supplied params.\n SignedMintValidationParams memory supplied = signedMintValidationParams;\n\n // Only the administrator (OpenSea) can set feeBps on Partner\n // contracts.\n if (msg.sender != administrator) {\n // Administrator must first set fee.\n if (retrieved.maxMaxTotalMintableByWallet == 0) {\n revert AdministratorMustInitializeWithFee();\n }\n supplied.minFeeBps = retrieved.minFeeBps;\n supplied.maxFeeBps = retrieved.maxFeeBps;\n } else {\n // Administrator can only initialize\n // (maxTotalMintableByWallet > 0) and set\n // feeBps/restrictFeeRecipients.\n uint24 maxMaxTotalMintableByWallet = retrieved\n .maxMaxTotalMintableByWallet;\n retrieved\n .maxMaxTotalMintableByWallet = maxMaxTotalMintableByWallet > 0\n ? maxMaxTotalMintableByWallet\n : 1;\n retrieved.minFeeBps = supplied.minFeeBps;\n retrieved.maxFeeBps = supplied.maxFeeBps;\n supplied = retrieved;\n }\n\n // Update the signed mint validation params.\n ISeaDrop(seaDropImpl).updateSignedMintValidationParams(\n signer,\n supplied\n );\n }","after":"function updateSignedMintValidationParams(\n address seaDropImpl,\n address signer,\n SignedMintValidationParams calldata signedMintValidationParams\n )\n external\n virtual\n override\n onlyOwnerOrAdministrator\n onlyAllowedSeaDrop(seaDropImpl)\n {\n // Track the previous signed mint validation params.\n SignedMintValidationParams memory retrieved = ISeaDrop(seaDropImpl)\n .getSignedMintValidationParams(address(this), signer);\n\n // Track the newly supplied params.\n SignedMintValidationParams memory supplied = signedMintValidationParams;\n\n // Only the administrator (OpenSea) can set feeBps on Partner\n // contracts.\n if (msg.sender != administrator) {\n // Administrator must first set fee.\n if (retrieved.maxMaxTotalMintableByWallet == 0) {\n revert AdministratorMustInitializeWithFee();\n }\n supplied.minFeeBps = retrieved.minFeeBps;\n supplied.maxFeeBps = retrieved.maxFeeBps;\n } else {\n // Administrator can only initialize\n // (maxTotalMintableByWallet > 0) and set\n // feeBps/restrictFeeRecipients.\n uint24 maxMaxTotalMintableByWallet = retrieved\n .maxMaxTotalMintableByWallet;\n retrieved\n .maxMaxTotalMintableByWallet = maxMaxTotalMintableByWallet > 0\n ? maxMaxTotalMintableByWallet\n : 1;\n retrieved.minFeeBps = supplied.minFeeBps;\n retrieved.maxFeeBps = supplied.maxFeeBps;\n supplied = retrieved;\n }\n\n // Update the signed mint validation params.\n ISeaDrop(seaDropImpl).updateSignedMintValidationParams(\n signer,\n supplied\n );\n }","contract":"ERC721PartnerSeaDrop","time":0}]}

{"time":81,"results":[{"type":"external-function ","before":"function updateSignedMintValidationParams(\n address seaDropImpl,\n address signer,\n SignedMintValidationParams memory signedMintValidationParams\n ) external virtual override onlyOwner onlyAllowedSeaDrop(seaDropImpl) {\n // Update the signer.\n ISeaDrop(seaDropImpl).updateSignedMintValidationParams(\n signer,\n signedMintValidationParams\n );\n }","after":"function updateSignedMintValidationParams(\n address seaDropImpl,\n address signer,\n SignedMintValidationParams calldata signedMintValidationParams\n ) external virtual override onlyOwner onlyAllowedSeaDrop(seaDropImpl) {\n // Update the signer.\n ISeaDrop(seaDropImpl).updateSignedMintValidationParams(\n signer,\n signedMintValidationParams\n );\n }","contract":"ERC721SeaDrop","time":0}]}

{"time":229,"results":[{"type":"constant-restrict-modification ","before":"uint256 internal immutable _CHAIN_ID = block.chainid;","after":"uint256 internal immutable constant _CHAIN_ID = block.chainid;","contract":"SeaDrop","time":0}]} (FP)

seaport:

{"time":60,"results":[{"type":"external-function ","before":"function fulfillAvailableAdvancedOrders(\n AdvancedOrder[] memory advancedOrders,\n CriteriaResolver[] calldata criteriaResolvers,\n FulfillmentComponent[][] calldata offerFulfillments,\n FulfillmentComponent[][] calldata considerationFulfillments,\n bytes32 fulfillerConduitKey,\n address recipient,\n uint256 maximumFulfilled\n )\n external\n payable\n override\n returns (bool[] memory availableOrders, Execution[] memory executions)\n {\n // Fulfill all available orders.\n return\n _fulfillAvailableAdvancedOrders(\n advancedOrders,\n criteriaResolvers,\n offerFulfillments,\n considerationFulfillments,\n fulfillerConduitKey,\n recipient == address(0) ? msg.sender : recipient,\n maximumFulfilled\n );\n }","after":"function fulfillAvailableAdvancedOrders(\n AdvancedOrder[] calldata advancedOrders,\n CriteriaResolver[] calldata criteriaResolvers,\n FulfillmentComponent[][] calldata offerFulfillments,\n FulfillmentComponent[][] calldata considerationFulfillments,\n bytes32 fulfillerConduitKey,\n address recipient,\n uint256 maximumFulfilled\n )\n external\n payable\n override\n returns (bool[] memory availableOrders, Execution[] memory executions)\n {\n // Fulfill all available orders.\n return\n _fulfillAvailableAdvancedOrders(\n advancedOrders,\n criteriaResolvers,\n offerFulfillments,\n considerationFulfillments,\n fulfillerConduitKey,\n recipient == address(0) ? msg.sender : recipient,\n maximumFulfilled\n );\n }","contract":"Consideration","time":0},
{"type":"external-function ","before":"function matchAdvancedOrders(\n AdvancedOrder[] memory advancedOrders,\n CriteriaResolver[] calldata criteriaResolvers,\n Fulfillment[] calldata fulfillments\n ) external payable override returns (Execution[] memory executions) {\n // Validate and match the advanced orders using supplied fulfillments.\n return\n _matchAdvancedOrders(\n advancedOrders,\n criteriaResolvers,\n fulfillments\n );\n }","after":"function matchAdvancedOrders(\n AdvancedOrder[] calldata advancedOrders,\n CriteriaResolver[] calldata criteriaResolvers,\n Fulfillment[] calldata fulfillments\n ) external payable override returns (Execution[] memory executions) {\n // Validate and match the advanced orders using supplied fulfillments.\n return\n _matchAdvancedOrders(\n advancedOrders,\n criteriaResolvers,\n fulfillments\n );\n }","contract":"Consideration","time":0}]}

v2-periphery:
{"time":70,"results":[{"type":"state-data-arrangement ","before":"\naddress public immutable factory;\nuint public immutable windowSize;\nuint8 public immutable granularity;\nuint public immutable periodSize;\nmapping(address => Observation[]) public pairObservations;","after":"uint public immutable windowSize;\nuint public immutable periodSize;\nmapping(address => Observation[]) public pairObservations;\naddress public immutable factory;\nuint8 public immutable granularity;\n","contract":"ExampleSlidingWindowOracle","time":0}]} (FP)

v3-periphery:
{"time":14,"results":[{"type":"struct-data-arrangement ","before":"\naddress pair\nuint256 liquidityToMigrate\nuint8 percentageToMigrate\naddress token0\naddress token1\nuint24 fee\nint24 tickLower\nint24 tickUpper\nuint256 amount0Min\nuint256 amount1Min\naddress recipient\nuint256 deadline\nbool refundAsETH","after":"uint256 liquidityToMigrate\nuint256 amount0Min\nuint256 amount1Min\nuint256 deadline\naddress pair\naddress token0\naddress token1\naddress recipient\nuint24 fee\nint24 tickLower\nint24 tickUpper\nuint8 percentageToMigrate\nbool refundAsETH\n","contract":"IV3Migrator","time":10}]}

{"time":272,"results":[{"type":"struct-data-arrangement ","before":"\nuint256 tokenId\naddress quoteTokenAddress\naddress baseTokenAddress\nstring quoteTokenSymbol\nstring baseTokenSymbol\nuint8 quoteTokenDecimals\nuint8 baseTokenDecimals\nbool flipRatio\nint24 tickLower\nint24 tickUpper\nint24 tickCurrent\nint24 tickSpacing\nuint24 fee\naddress poolAddress","after":"uint256 tokenId\nstring quoteTokenSymbol\nstring baseTokenSymbol\naddress quoteTokenAddress\naddress baseTokenAddress\naddress poolAddress\nint24 tickLower\nint24 tickUpper\nint24 tickCurrent\nint24 tickSpacing\nuint24 fee\nuint8 quoteTokenDecimals\nuint8 baseTokenDecimals\nbool flipRatio\n","contract":"NFTDescriptor","time":63}]}

{"time":98,"results":[{"type":"struct-data-arrangement ","before":"\nstring quoteToken\nstring baseToken\naddress poolAddress\nstring quoteTokenSymbol\nstring baseTokenSymbol\nstring feeTier\nint24 tickLower\nint24 tickUpper\nint24 tickSpacing\nint8 overRange\nuint256 tokenId\nstring color0\nstring color1\nstring color2\nstring color3\nstring x1\nstring y1\nstring x2\nstring y2\nstring x3\nstring y3","after":"string quoteToken\nstring baseToken\nstring quoteTokenSymbol\nstring baseTokenSymbol\nstring feeTier\nuint256 tokenId\nstring color0\nstring color1\nstring color2\nstring color3\nstring x1\nstring y1\nstring x2\nstring y2\nstring x3\nstring y3\naddress poolAddress\nint24 tickLower\nint24 tickUpper\nint24 tickSpacing\nint8 overRange\n","contract":"NFTSVG","time":0}]}

{"time":202,"results":[{"type":"struct-data-arrangement ","before":"\naddress token0\naddress token1\nuint24 fee1\nuint256 amount0\nuint256 amount1\nuint24 fee2\nuint24 fee3","after":"uint256 amount0\nuint256 amount1\naddress token0\naddress token1\nuint24 fee1\nuint24 fee2\nuint24 fee3\n","contract":"PairFlash","time":0},
{"type":"external-function ","before":"function initFlash(FlashParams memory params) external {\n PoolAddress.PoolKey memory poolKey =\n PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});\n IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));\n // recipient of borrowed amounts\n // amount of token0 requested to borrow\n // amount of token1 requested to borrow\n // need amount 0 and amount1 in callback to pay back pool\n // recipient of flash should be THIS contract\n pool.flash(\n address(this),\n params.amount0,\n params.amount1,\n abi.encode(\n FlashCallbackData({\n amount0: params.amount0,\n amount1: params.amount1,\n payer: msg.sender,\n poolKey: poolKey,\n poolFee2: params.fee2,\n poolFee3: params.fee3\n })\n )\n );\n }","after":"function initFlash(FlashParams calldata params) external {\n PoolAddress.PoolKey memory poolKey =\n PoolAddress.PoolKey({token0: params.token0, token1: params.token1, fee: params.fee1});\n IUniswapV3Pool pool = IUniswapV3Pool(PoolAddress.computeAddress(factory, poolKey));\n // recipient of borrowed amounts\n // amount of token0 requested to borrow\n // amount of token1 requested to borrow\n // need amount 0 and amount1 in callback to pay back pool\n // recipient of flash should be THIS contract\n pool.flash(\n address(this),\n params.amount0,\n params.amount1,\n abi.encode(\n FlashCallbackData({\n amount0: params.amount0,\n amount1: params.amount1,\n payer: msg.sender,\n poolKey: poolKey,\n poolFee2: params.fee2,\n poolFee3: params.fee3\n })\n )\n );\n }","contract":"PairFlash","time":0}]}

{"time":25,"results":[{"type":"external-function ","before":"function multicall(Call[] memory calls) public returns (uint256 blockNumber, Result[] memory returnData) {\n blockNumber = block.number;\n returnData = new Result[](calls.length);\n for (uint256 i = 0; i < calls.length; i++) {\n (address target, uint256 gasLimit, bytes memory callData) =\n (calls[i].target, calls[i].gasLimit, calls[i].callData);\n uint256 gasLeftBefore = gasleft();\n (bool success, bytes memory ret) = target.call{gas: gasLimit}(callData);\n uint256 gasUsed = gasLeftBefore - gasleft();\n returnData[i] = Result(success, gasUsed, ret);\n }\n }","after":"function multicall(Call[] calldata calls) public returns (uint256 blockNumber, Result[] memory returnData) {\n blockNumber = block.number;\n returnData = new Result[](calls.length);\n for (uint256 i = 0; i < calls.length; i++) {\n (address target, uint256 gasLimit, bytes memory callData) =\n (calls[i].target, calls[i].gasLimit, calls[i].callData);\n uint256 gasLeftBefore = gasleft();\n (bool success, bytes memory ret) = target.call{gas: gasLimit}(callData);\n uint256 gasUsed = gasLeftBefore - gasleft();\n returnData[i] = Result(success, gasUsed, ret);\n }\n }","contract":"UniswapInterfaceMulticall","time":0}]}
